<?php
// Подключаем "библиотеку" qrlock. Вообще называть ее библиотекой будет не верно, это просто вынесенные в отдельный php-файл
// функции и определения, которые нет необходимости менять для запуска данного примера. Есстественно, здесь подставить свой путь.
require_once(__DIR__.'/../../jLIB.PHP/qrlock/qrlock.php');

// Обрабатываем полученный запрос на формирование пакета с контентом
// параметр content_id описан в файле index.php. Здесь, как мы видим, мы просто пишем контент прямо в коде, но могли бы обратиться
// по данному идентифкатору к базе данных или получить контент их какого-то внешнего источника. В нашем пример их два, третий (default)
// никогда не будет показан и приведен здесь только для обработки ошибочных действий.
$content = '';
switch($_POST['content_id']) {
 case 'bla-bla-bla-1':
  $content = 'Первый вид контента';
  break;
 case 'bla-bla-bla-2':
  $content = 'Второй вид контента';
  break;
 default:
  $content = 'Неизвестный вид контента';
  break;
}
// Собственно сам пакет, отправляемый на наш сервер. Формат отправки - JSON.
$param = [
 'data' => json_encode([
// Версия пакета, на сегодняшний день не используется вообще, задел на будущее, оставить 1 до дальнейших рекомендаций.
  'ver' => 1,
// Ключ АПИ. Выдается (пока) в ручном режиме. Ваш собственный ключ. ВАЖНО!!! не публикуйте его нигде, по нему определются лимиты запросов.
// Если кто-то его узнает, то сможет выполнять запросы к сервису под вашим именем.
  'auth' => __API_AUTH__,
// Команда "Создать пакет". Основная (и пока единственная) используемая команда.
  'cmd' => _QRL_CMD_CNT_CRT_,
// Собственно контент
  'content' => [
// Версия контента. На сегодняшний день пока одна, оставить 1
   1, // Only one version today
// Тип контента. Здесь (и во всехтекущих примерах) указан "обычный текстовый контент".
// Данный вид контента хорошо подходит под какую-то текстувую информацию, кусок HTML-кода, какой-то код, пароль или прочее, что необходимо
// спрятать от всех обычных пользователей СЕО и прочих роботов, каких-либо abuse-еров или даже воров контента. Не стоит пытаться передавать
// очень большой размер контента. Во-первых, наша база не резиновая, во-вторых, совершенно незачем гонять впустую гигантские объемы данных,
// а в третьих, если все же есть желание передать большой объем данных, то вполне можно сохранить его где-то на сервисах, выполняющих это
// гораздо лучше (CDN, Cloud hosting, etc.) и здесь передать только линку на него.
   _QRL_CNT_TYPE_PLN_,
// Собственно контент. См. выше как он был получен.
   $content,
  ],
// ВАЖНО!!! Уникальный идентификатор пользователя. Он необходим чтобы система могла отличить нескольких пользователей, просматривающих один
// и тот же контент в одно и тоже время. Ибо если этог оне сделать, то система покажет им одинаковый QR-код и один пользователь отсканировав
// его, откроет контент и для второго пользователя. Таким образом вы "потеряете" второго пользователя.
// В данном случае используется самый простой вариант как хеш от IP пользователя и юзерагента. В большинстве случаев этого будет достаточно,
// однако если у вас ест ьвозможность более точной идентификации пользователя (например уникальные cookie сайта), то лучше их добавить сюда.
// Должен представлять собой MD5.
// ВАЖНО!!! Если данный файл будет вызываться через какие-то виды прокси (например Cloudflare), то здесь будет IP-адрес и юзерагент прокси.
// Необходимо озаботиться в данном случае чтобы получить реальный IP-адрес и юзерагент пользователя. Обращайтесь в нашу тех. поддержку,
// Будем решать данный вопрос вместе.
  'fpr' => md5($_SERVER['HTTP_USER_AGENT'].$_SERVER['REMOTE_ADDR']),
// Данный параметр описан в файле index.php. Сюда он прост опередается при вызове данного файла с параметрами.
// Вот как раз здесь и можно будет "скрыть" его от пользователя и указать какой-то свой, который нельзя показывать пользователю.
  'urlmob' => isset($_POST['urlmob'])?$_POST['urlmob']:false,
// Если его не указывать или указать как false, то после нажатия кнопки на мобильном устройстве, пользователь никуда не будет отправлен,
// однако контент будет получен и показан как в обычном цикле работы сервиса.
  //'urlmob' =>false,
// Юзерагент. На сегодняшний день используется для отладки сервиса. Можно либо не задават ьего вообще, либо указать как false.
  'ua' => $_SERVER['HTTP_USER_AGENT'],
 ]),
];
// Отправка пакета на наш сервер
$res = PostCurl(__API_POINT__,$param);
// Печать результата. В данном случае не выполняется никаких проверок по получению (не получению) результата или обработки ошибок.
// Считается что результат будет получен всегда. Если произойдте ошибка, об этом просто будет сообщено в соотвествующем поле (см. файл дизайна темплейта).
e($res);
